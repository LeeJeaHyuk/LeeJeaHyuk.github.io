# 합성곱 신경망의 시각화

## 가중치 시각화

![image-20220607202303567](../../images/2022-06-07-합성곱 신경망의 시각화(혼공머신8-3)/image-20220607202303567.png)

그림에서는 둥근 모서리가 있는 부분이 출력이 가중치가 곱해졌을 때 출력이 더 높게 나와야 하기 때문에

 둥근 모서리가 있는 부분의 가중치값은 높아야 할 것이다.

```python
model.layers
# [<keras.layers.convolutional.conv2d.Conv2D at 0x7f1da1df4250>,
#  <keras.layers.pooling.max_pooling2d.MaxPooling2D at 0x7f1da1df4fa0>,
#  <keras.layers.convolutional.conv2d.Conv2D at 0x7f1da0533730>,
#  <keras.layers.pooling.max_pooling2d.MaxPooling2D at 0x7f1da04ec4f0>,
#  <keras.layers.reshaping.flatten.Flatten at 0x7f1da04fe9a0>,
#  <keras.layers.core.dense.Dense at 0x7f1da04fef40>,
#  <keras.layers.regularization.dropout.Dropout at 0x7f1da04feca0>,
#  <keras.layers.core.dense.Dense at 0x7f1da0506d30>]
# 합성곱-풀링-합성곱2-풀링-dense-dropout-dense 의 순서

conv = model.layers[0]

print(conv.weights[0].shape, conv.weights[1].shape)
#(3, 3, 1, 32) (32,)
# 3x3x1필터 32개 사용 절편도 32개의 1차원 벡터로 구성
# conv.weights에는 필터(커널)와 가중치 정보가 있다


```



### 가중치 시각화

```python
conv_weights = conv.weights[0].numpy()
print(conv_weights.mean(), conv_weights.std())
# -0.021033935 0.23466988

plt.hist(conv_weights.reshape(-1, 1))
#conv_weights:(3, 3, 1, 32)를 1차원으로 펼치기
plt.xlabel('weight')
plt.ylabel('count')
plt.show()
```

![image-20220607203201081](../../images/2022-06-07-합성곱 신경망의 시각화(혼공머신8-3)/image-20220607203201081.png)

```python
fig, axs = plt.subplots(2, 16, figsize=(15,2))

for i in range(2):
    for j in range(16):
        axs[i, j].imshow(conv_weights[:,:,0,i*16 + j], vmin=-0.5, vmax=0.5)
        #imshow는 '상대적으로' 최소값을 가장 어둡게 최대값을 가장 밝게 표현한다 각 이미지의 색이 같다고 해도 값이 같은 것은 아니다
        # vmin=-0.5, vmax=0.5를 통해서 가중치를 서로 비교할 수 있게 해준다.
        axs[i, j].axis('off')

plt.show()
```

![image-20220607203948094](../../images/2022-06-07-합성곱 신경망의 시각화(혼공머신8-3)/image-20220607203948094.png)




## 함수형 API

```python
```

